
#include "zone-parse.h"
#include "zone-atom.h"
#include "util-base64-b.h"

#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>


size_t
zone_atom_base64b(const char *data, size_t cursor, size_t max,
                   struct wire_record_t *out, unsigned *depth)
{
    int err = 0;
    size_t out_len = 0;
    size_t next = base64decode(data + cursor,
                               max - cursor,
                               out->wire.buf + out->wire.len,
                               &out_len,
                               &err);
    if (err && !out->err.code) {
        return PARSE_ERR(1, cursor, max, out);
    }
    
    return next;
}

/* -------------------------------------------------------------------------- */
/* Quicktest                                                                   */
/* -------------------------------------------------------------------------- */

struct b64tc {
    const char *b64;
    size_t out_len;
    uint8_t out16[16];
};

/* These were generated from a deterministic PRNG seed (9460) and then
 * “mutated” by inserting tabs/spaces and occasional parentheses/newlines.
 * All cases decode to <= 16 bytes.
 */
static const struct b64tc b64_cases[] = {
    { "h37C\tRW/ ffIwjSxw=\n", 11, { 0x87, 0x7e, 0xc2, 0x45, 0x6f, 0xdf, 0x7c, 0x8c, 0x23, 0x4b, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "UBym1Q==\n", 4, { 0x50, 0x1c, 0xa6, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "5K\tToR(\nFIM6h8=\n)\n", 8, { 0xe4, 0xa4, 0xe8, 0x44, 0x52, 0x0c, 0xea, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "r\t7k=\n", 2, { 0xaf, 0xb9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "t0\t0o\n", 3, { 0xb7, 0x4d, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "f\t6c=\n", 2, { 0x7f, 0xa7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "c\tR9S\n", 3, { 0x71, 0x1f, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "a\tY\n", 1, { 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "v\tt\n", 1, { 0xbe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "6w==\n", 1, { 0xeb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "f\tQ\n", 1, { 0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "d\tE\n", 1, { 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "Q\tA\n", 1, { 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "pQ==\n", 1, { 0xa5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "u\tQ\n", 1, { 0xb9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "K\tA\n", 1, { 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "Q\tQ\n", 1, { 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "eQ==\n", 1, { 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "V\tw\n", 1, { 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "mA==\n", 1, { 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "V\tQ\n", 1, { 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "f\tw\n", 1, { 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "q\tQ\n", 1, { 0xa9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "Y\tA\n", 1, { 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
    { "Y\tQ\n", 1, { 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
};

int
zone_atom_base64b_quicktest(void)
{
    int failures = 0;

    for (size_t i = 0; i < sizeof(b64_cases) / sizeof(b64_cases[0]); i++) {
        const struct b64tc *tc = &b64_cases[i];

        uint8_t wire[64+1024];
        struct wire_record_t out;
        unsigned depth = 0;

        memset(&out, 0, sizeof(out));
        out.wire.buf = wire;
        out.wire.max = 64;

        /*
         * Run test
         */
        (void)zone_atom_base64b(tc->b64, 0, strlen(tc->b64), &out, &depth);

        if (out.err.code != 0) {
            fprintf(stderr, "base64es tc[%zu]: unexpected err_code=%u at cursor=%zu\n",
                    i, out.err.code, out.err.cursor);
            failures++;
            continue;
        }

        if (out.wire.len != tc->out_len) {
            fprintf(stderr, "base64es tc[%zu]: length mismatch got=%zu expected=%zu\n",
                    i, out.wire.len, tc->out_len);
            failures++;
            continue;
        }

        if (memcmp(out.wire.buf, tc->out16, tc->out_len) != 0) {
            fprintf(stderr, "base64es tc[%zu]: bytes mismatch (first %zu bytes)\n",
                    i, tc->out_len);
            fprintf(stderr, "  got: ");
            for (size_t k = 0; k < tc->out_len; k++)
                fprintf(stderr, "%02x", (unsigned)out.wire.buf[k]);
            fprintf(stderr, "\n  exp: ");
            for (size_t k = 0; k < tc->out_len; k++)
                fprintf(stderr, "%02x", (unsigned)tc->out16[k]);
            fprintf(stderr, "\n");
            failures++;
            continue;
        }
    }

    if (failures == 0) {
        printf("zone_atom_base64es_quicktest: OK (%zu cases)\n",
               sizeof(b64_cases) / sizeof(b64_cases[0]));
    } else {
        printf("zone_atom_base64es_quicktest: FAIL (%d failures)\n", failures);
    }

    return failures;
}

